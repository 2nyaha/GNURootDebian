#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <limits.h> /* PATH_MAX */
#include <sys/param.h> /* MAXSYMLINKS, */
#include <linux/binfmts.h> /* BINPRM_BUF_SIZE, */

#include "extension/extension.h"
#include "tracee/tracee.h"
#include "tracee/mem.h"
#include "syscall/syscall.h"
#include "syscall/sysnum.h"
#include "syscall/chain.h"
#include "path/path.h"
#include "arch.h"
#include "attribute.h"
#include "execve/elf.h"
#include "execve/shebang.h"

#define SHADOW_PATH "/noexec/"
#define META_PATH "/meta/"
#define LINK_PREFIX ".l2s."
#define DELETED_SUFFIX " (deleted)"

int temporary_fd;

static int my_readlink(Tracee *tracee, char symlink[PATH_MAX], char value[PATH_MAX])
{
	ssize_t size;
	char temp[PATH_MAX];
	int status;
	char *name;

	size = readlink(symlink, value, PATH_MAX);
	if (size < 0)
		return size;
	if (size >= PATH_MAX)
		return -ENAMETOOLONG;
	value[size] = '\0';

	//always make the result be an absolute path
	if (value[0] != '/') {
		name = strrchr(symlink,'/');
		if (name == NULL)
			name = symlink;
		else
			name++;

		strncpy(temp, symlink, strlen(symlink) - strlen(name));
		temp[strlen(symlink) - strlen(name)] = '\0';
		strcat(temp, value);
		strcpy(value, temp);
	}

	status = translate_path_and_notify(tracee, temp, AT_FDCWD, value, false, false); 
	if (status == 0)
		strcpy(value, temp);

	return 0;
}

static int my_symlink(Tracee *tracee, const char old_path[PATH_MAX], char new_path[PATH_MAX])
{
	int status;
	char shadow_path[PATH_MAX];
	char temp_path[PATH_MAX];
 
	status = translate_path_and_notify(tracee, shadow_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	strcpy(temp_path, old_path);
	if (strncmp(temp_path, shadow_path, strlen(shadow_path)) == 0) {
		status = detranslate_path(tracee, temp_path, NULL);
		if (status < 0)
			return status;
	}

	status = symlink(temp_path, new_path);
	if (status < 0)
		return status;
	
	return 0;
}

/******************************************************
 * Get path to the meta file associated with a shadow
 * file 
 ******************************************************/
static int get_meta_path(Tracee *tracee, char meta_path[PATH_MAX], char shadow_path[PATH_MAX]) {
	char shadow_orig[PATH_MAX];
	char meta_orig[PATH_MAX];
	int status;

	//detranslate, replace SHADOW_PATH with META_PATH and then translate
	strcpy(shadow_orig, shadow_path);
	status = detranslate_path(tracee, shadow_orig, NULL);
	if (status < 0)
		return status;
	strcpy(meta_orig, META_PATH);
	strcat(meta_orig, shadow_orig + strlen(SHADOW_PATH));
	status = translate_path_and_notify(tracee, meta_path, AT_FDCWD, meta_orig, false, false); 
	if (status < 0)
		return status;
	return 0;
}

/******************************************************
 * Create a new meta file corresponding to a shadow
 * file
 ******************************************************/
static int creat_meta(Tracee *tracee, char original_path[PATH_MAX], char shadow_path[PATH_MAX], Reg mode_sysarg) {

	word_t mode;
	int status;
	char meta_path[PATH_MAX];

	//get mode
	mode = peek_reg(tracee, ORIGINAL, mode_sysarg);

	printf("creat_meta shadow_path: %s\n", shadow_path);
	//get meta path
	status = get_meta_path(tracee, meta_path, shadow_path);
	if (status < 0)
		return status;

	//create meta file
	status = creat(meta_path,mode);
	if (status < 0)
		return status;

	close(status);

	//modify meta path to be the linkback path
	strcat(meta_path,"_linkback");
	printf("creat_meta meta_path: %s\n", meta_path);

	//create a symlink from the linkback to the original file
        status = my_symlink(tracee, original_path, meta_path);
	printf("creat_meta symlink status: %d\n", status);
        if (status < 0)
		return status;

	return 0;
}

/******************************************************
 * Rename a meta file corresponding to a rename of a
 * shadow file
 ******************************************************/
static int rename_meta(Tracee *tracee, char old_shadow_path[PATH_MAX], char new_shadow_path[PATH_MAX]) {

	int status;
	char old_meta_path[PATH_MAX];
	char new_meta_path[PATH_MAX];

	//get old meta path
	status = get_meta_path(tracee, old_meta_path, old_shadow_path);
	if (status < 0)
		return status;

	//get new meta path
	status = get_meta_path(tracee, new_meta_path, new_shadow_path);
	if (status < 0)
		return status;
	printf("rename_meta old: %s new: %s\n", old_meta_path, new_meta_path); 

	//rename the old meta to the new
	status = rename(old_meta_path, new_meta_path);
	if (status < 0)
		return status;

	//modify meta paths to be linkback paths
	strcat(old_meta_path,"_linkback");
	strcat(new_meta_path,"_linkback");

	//rename the old meta linkback to the new linkback
	status = rename(old_meta_path, new_meta_path);
	if (status < 0)
		return status;

	return 0;
}

/******************************************************
 * Unlink a meta file corresponding to a shadow file
 ******************************************************/
static int unlink_meta(Tracee *tracee, char shadow_path[PATH_MAX]) {

	int status;
	char meta_path[PATH_MAX];

	//get old meta path
	status = get_meta_path(tracee, meta_path, shadow_path);
	if (status < 0)
		return status;

	//unlink meta file
	status = unlink(meta_path);
	if (status < 0)
		return status;

	//modify meta path to be linkback path
	strcat(meta_path,"_linkback");

	//unlink meta linkback file
	status = unlink(meta_path);
	if (status < 0)
		return status;

	return 0;
}

/**
 * Copy file, possibly accross partitions
 * returns 0 if nothing to do, 1 on success and a negative value of failure
 */
int copy_executable(Tracee *tracee, char shadow_path[PATH_MAX], char final_path[PATH_MAX])
{
	char buf[BUFSIZ];
	size_t size;
	int source;
	int dest;
	int status;
	struct stat statl;
	char shadow_root_path[PATH_MAX];
	char meta_path[PATH_MAX];
	char linkback_path[PATH_MAX];

	//get host path corresponding to SHADOW_PATH
	status = translate_path_and_notify(tracee, shadow_root_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	//only copy the executable if the path is pointing at a shadowed file
	if (strncmp(shadow_path, shadow_root_path, strlen(shadow_root_path)) != 0)
		return 0; 

	//figure out the meta linkback path
	status = get_meta_path(tracee, meta_path, shadow_path); 
	if (status < 0)
		return status;
	strcpy(linkback_path, meta_path);
	strcat(linkback_path, "_linkback");
	printf("copy_executable meta_path: %s\n", meta_path);
	printf("copy_executable linkback_path: %s\n", linkback_path);

	//the copy may have already occurred, in those cases, don't actually do the copy
	status = lstat(linkback_path, &statl);
	if (status < 0) {
		printf("copy_executable, file already copied\n");
		return 1;
	}
	//read the linkback link to find out where to copy to
	status = my_readlink(tracee, linkback_path, final_path);
	if (status < 0)
		return status;
	printf("copy_executable final_path: %s\n", final_path);

	//TODO: should really be checking timestamp to not copy down things already copied
	//TODO: maybe should push back to shadow when file openned for write only
	//delete link we are replacing
	status = unlink(final_path);
	if (status < 0)
		return status;
	printf("copy_executable deleted link\n");

	status = rename(meta_path, final_path);
	if (status < 0)
		return status;
	printf("copy_executable copied meta file\n");

	source = open(shadow_path, O_RDONLY);
	if (source < 0)
		return source;
	dest = open(final_path, O_WRONLY, 0777);
	if (dest < 0)
		return dest;

	while ((size = read(source, buf, BUFSIZ)) > 0) {
		write(dest, buf, size);
	}

	close(source);
	close(dest);

	printf("copy_executable done copying\n");

	status = unlink(linkback_path);
	if (status < 0)
		return status;

	status = unlink(shadow_path);
	if (status < 0)
		return status;
	printf("copy_executable done\n");

	return 1;
}


/******************************************************
 * Get a path for a new shadow file  
 ******************************************************/
static int new_shadow_file_path(Tracee *tracee, char file_path[PATH_MAX]) {
	int directory;
	int file;
	long itteration;
	char temp_path[PATH_MAX];
	char dir_path[PATH_MAX];
	char meta_dir_path[PATH_MAX];
	int status;

	//find a file name that hasn't been used yet
	for (itteration = 0; itteration < 1000000; itteration++) {
		directory = rand() % 10000;
		file = rand() % 10000;
		sprintf(temp_path, "%s%04d/", SHADOW_PATH, directory);		
		status = translate_path_and_notify(tracee, dir_path, AT_FDCWD, temp_path, false, false); 
		if (status < 0)
			return status;
		sprintf(file_path, "%s%04d", dir_path, file);		
		if (access(file_path, F_OK) == -1) {
			mkdir(dir_path, 0777);
			status = get_meta_path(tracee, meta_dir_path, dir_path); 
			if (status < 0)
				return status;
			mkdir(meta_dir_path, 0777);
			return 0;
		}
	}

	return -1;
} 

/**
 *get path to where actual file lives
 *handle shadowing
 *handle fake hard links
 *return number of links if found, 0 if not found and a negative value if an error encountered
 */
static int link_shadow_path(Tracee *tracee, char final_path[PATH_MAX], char orig_path[PATH_MAX], bool follow_symlinks)
{
	int size;
	int status;
	struct stat statl;
	char temp[PATH_MAX];
	char *name;
	int link_count;
	int loop_count;
	char shadow_path[PATH_MAX];
	char * period;

	//intially copy orig to final path
	strcpy(final_path, orig_path);

	//if file doesn't exist, get out 
	status = lstat(final_path, &statl);
	if (status < 0)
		return 0;	

	//get file name
	name = strrchr(final_path, '/');
	if (name == NULL)
		name = final_path;
	else
		name++;

	//if starting at a file in the middle of a fake hardlink, get out 
	if (strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) == 0) 
		return 1;	

	//get host path corresponding to SHADOW_PATH
	status = translate_path_and_notify(tracee, shadow_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	for (loop_count = 0; loop_count <= MAXSYMLINKS; loop_count++) {

	
		status = lstat(final_path, &statl);
		//if file doesn't exist, get out 
		if (status < 0)
			break;

		//if it is not a link, get out
		if (!S_ISLNK(statl.st_mode))
			break;	

		//read where the link is pointing to
		size = my_readlink(tracee, final_path, temp);
		if (size < 0)
			return size;

		//get file name
		name = strrchr(temp, '/');
		if (name == NULL)
			name = temp;
		else
			name++;

		//if  not a shadow link,
		//the link is not fake hard link and 
		//we are not setup to follow regular links, get out
		if ((strncmp(temp, shadow_path, strlen(shadow_path)) != 0) && 
			(strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) != 0) && 
			(follow_symlinks == false))
			break;

		//otherwise, copy new path into intermediate and continue
		strcpy(final_path, temp);

	}

	//if we had too many symbolic links, return appropriate status
	if (loop_count > MAXSYMLINKS)
		return -ELOOP;

	//get file name
	name = strrchr(final_path, '/');
	if (name == NULL)
		name = final_path;
	else
		name++;

	//find if/where there is a period in the name
	period = strchr(name, '.');

	//if in the end it was a file that was not a fake hard link, return 1 
	if ((strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) != 0) && ((strncmp(final_path, shadow_path, strlen(shadow_path)) != 0) || (period == NULL)))
		return 1;

	//otherwise extract and return the link count from the end of the file name 
	link_count = atoi(final_path + strlen(final_path) - 4);
	return link_count;

}

/******************************************************
 * Change a path sysarg to point at meta file if
 * it is a shadow file path
 ******************************************************/
static int set_meta_path(Tracee *tracee, Reg path_sysarg) {

	int status;
	int size;
	char orig_path[PATH_MAX];
	char shadow_path[PATH_MAX];
	char shadow_root_path[PATH_MAX];
	char meta_path[PATH_MAX];
	word_t src;

	//get original path
	//first check if path is NULL - TODO: this is for utimensat, need to check if it interfers with others
	src = peek_reg(tracee, CURRENT, path_sysarg);
	if (src == 0) {
		status = readlink_proc_pid_fd(tracee->pid, peek_reg(tracee, CURRENT, SYSARG_1), orig_path);
		if (status < 0)
			return status;
		if (strcmp(orig_path + strlen(orig_path) - strlen(DELETED_SUFFIX), DELETED_SUFFIX) == 0)
			orig_path[strlen(orig_path) - strlen(DELETED_SUFFIX)] = '\0'; 
	} else {
		size = read_string(tracee, orig_path, peek_reg(tracee, CURRENT, path_sysarg), PATH_MAX);
		if (size < 0)
                	return size;
        	if (size >= PATH_MAX)
                	return -ENAMETOOLONG;
	}

	//get where final file really is 
	status = link_shadow_path(tracee, shadow_path, orig_path, true);
	if (status <= 0)
		return status;

	//get host path corresponding to SHADOW_PATH
	status = translate_path_and_notify(tracee, shadow_root_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	//only modify the path sysarg if it was pointing at a shadow file
	if (strncmp(shadow_path, shadow_root_path, strlen(shadow_root_path)) != 0)
		return 0; 

	//get meta path
	status = get_meta_path(tracee, meta_path, shadow_path);
	if (status < 0)
		return status;

	//modify path sysarg to point at shadow location
	return set_sysarg_path(tracee, meta_path, path_sysarg);

}

/**
 * Move the path pointed to by @tracee's @sysarg to a new location,
 * symlink the original path to this new one, make @tracee's @sysarg
 * point to the new location.  This function returns -errno if an
 * error occured, otherwise 0.
 */
static int move_and_symlink_path(Tracee *tracee, Reg sysarg)
{
	char original[PATH_MAX];
	char intermediate[PATH_MAX];
	char new_intermediate[PATH_MAX];
	char final[PATH_MAX];
	char new_final[PATH_MAX];
	char shadow[PATH_MAX];
	char shadow_path[PATH_MAX];
	char * name;
	struct stat statl;
	ssize_t size;
	int status;
	int link_count;
	int first_link = 1;
	int shadow_link = 0;
	int intermediate_suffix = 1;

	/* Note: this path was already canonicalized.  */
	size = read_string(tracee, original, peek_reg(tracee, CURRENT, sysarg), PATH_MAX);
	if (size < 0)
		return size;
	if (size >= PATH_MAX)
		return -ENAMETOOLONG;

	/* Sanity check: directories can't be linked.  */
	status = lstat(original, &statl);
	if (status < 0)
		return status;
	if (S_ISDIR(statl.st_mode))
		return -EPERM;

	status = translate_path_and_notify(tracee, shadow_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	/* Check if it is a symbolic link.  */
	if (S_ISLNK(statl.st_mode)) {
		/* get name */
		size = my_readlink(tracee, original, intermediate);
		if (size < 0)
			return size;

		name = strrchr(intermediate, '/');
		if (name == NULL)
			name = intermediate;
		else
			name++;

		if (strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) == 0)
			first_link = 0;

		if (strncmp(intermediate, shadow_path, strlen(shadow_path)) == 0) {
			shadow_link = 1;
			strcpy(shadow, intermediate);
		}
	}

	if (first_link) {
		/* compute new name */
		if (strlen(LINK_PREFIX) + strlen(original) + 5 >= PATH_MAX)
			return -ENAMETOOLONG;

		name = strrchr(original,'/');
		if (name == NULL)
			name = original;
		else
			name++;

		strncpy(intermediate, original, strlen(original) - strlen(name));
		intermediate[strlen(original) - strlen(name)] = '\0';
		strcat(intermediate, LINK_PREFIX);
		strcat(intermediate, name);

		/*Move the original content to the new path. */
		do {
			sprintf(new_intermediate, "%s%04d", intermediate, intermediate_suffix);		
			intermediate_suffix++;
		} while ((access(new_intermediate,F_OK) != -1) && (intermediate_suffix < 1000)); 
		strcpy(intermediate, new_intermediate);

		if (shadow_link) {
			strcpy(final, shadow);
			strcat(final, ".0002");
			status = rename(shadow, final);
			if (status < 0)
				return status;
			status = rename_meta(tracee, shadow, final);
			if (status < 0)
				return status;
			//put place holder so no other shadow file takes this name until all is clear
			status = creat(shadow,0777);
			if (status < 0)
				return status;
			//blow away original
			status = unlink(original);
			if (status < 0)
				return status;
		} else {
			strcpy(final, intermediate);
			strcat(final, ".0002");
			status = rename(original, final);
			if (status < 0)
				return status;
		}

		/* Symlink the intermediate to the final file.  */
		status = my_symlink(tracee, final, intermediate);
		if (status < 0)
			return status;	

		/* Symlink the original path to the intermediate one.  */
        	status = my_symlink(tracee, intermediate, original);
        	if (status < 0)
			return status;
	} else {
		/*Move the original content to new location, by incrementing count at end of path. */
		size = my_readlink(tracee, intermediate, final);
		if (size < 0)
			return size;

		link_count = atoi(final + strlen(final) - 4);
		link_count++;

		strncpy(new_final, final, strlen(final) - 4);
		sprintf(new_final + strlen(final) - 4, "%04d", link_count);		
		
		status = rename(final, new_final);
		if (status < 0)
			return status;
		if (shadow_link) {
			status = rename_meta(tracee, final, new_final);
			if (status < 0)
				return status;
		}
		strcpy(final, new_final);

		/* Symlink the intermediate to the final file.  */
		status = unlink(intermediate);
		if (status < 0)
			return status;
		status = my_symlink(tracee, final, intermediate);
		if (status < 0)
			return status;
	}
	
	status = set_sysarg_path(tracee, intermediate, sysarg);
	if (status < 0)
		return status;

	set_sysnum(tracee, PR_symlink);

	return 0;
}

/* If path points a file that is a symlink to a file that begins
 *   with PREFIX, let the file be deleted, but also delete the 
 *   symlink that was created and decrement the count that is tacked
 *   to end of original file.
 */
static int decrement_link_count(Tracee *tracee, Reg sysarg)
{
	char original[PATH_MAX];
	char intermediate[PATH_MAX];
	char final[PATH_MAX];
	char shadow[PATH_MAX];
	char shadow_path[PATH_MAX];
	char new_final[PATH_MAX];
	char * name;
	struct stat statl;
	ssize_t size;
	int status;
	int link_count;

	/* Note: this path was already canonicalized.  */
	size = read_string(tracee, original, peek_reg(tracee, CURRENT, sysarg), PATH_MAX);
	if (size < 0)
		return size;
	if (size >= PATH_MAX)
		return -ENAMETOOLONG;
	printf("decrement original: %s\n", original);

	name = strrchr(original, '/');
	if (name == NULL)
		name = original;
	else
		name++;
	//if in the middle of a fake hardlink, do nothing
	if (strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) == 0) { 
		set_sysnum(tracee, PR_void);
		return 0;
	}

	/* Check if it is a converted link already.  */
	status = lstat(original, &statl);
	if (status < 0)
		return 0;

	//if it is not a link, get out
	if (!S_ISLNK(statl.st_mode)) 
		return 0;

	//get where link is pointing
	size = my_readlink(tracee, original, intermediate);
	if (size < 0)
		return size;

	//get translated version of SHADOW_PATH
	status = translate_path_and_notify(tracee, shadow_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	//if it is a link pointing to a shadow file, unlink that file
	if (strncmp(intermediate, shadow_path, strlen(shadow_path)) == 0) {
		status = unlink(intermediate);
		if (status < 0)
			return status;
		status = unlink_meta(tracee, intermediate);
		if (status < 0)
			return status;
		return 0;
	}

	name = strrchr(intermediate, '/');
	if (name == NULL)
		name = intermediate;
	else
		name++;

	/* Check if an l2s file is pointed to */
	if (strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) != 0) 
		return 0;

	size = my_readlink(tracee, intermediate, final);
	if (size < 0)
		return size;

	link_count = atoi(final + strlen(final) - 4);
	link_count--;

	/* Check if it is or is not the last link to delete */
	if (link_count > 0) {
		strncpy(new_final, final, strlen(final) - 4);
		sprintf(new_final + strlen(final) - 4, "%04d", link_count);		
	
		status = rename(final, new_final);
		if (status < 0)
			return status;				
		if (strncmp(final, shadow_path, strlen(shadow_path)) == 0) {
			status = rename_meta(tracee, final, new_final);
			if (status < 0)
				return status;				
		}
			
		strcpy(final, new_final);

		/* Symlink the intermediate to the final file.  */
		status = unlink(intermediate);
		if (status < 0)
			return status;

		status = my_symlink(tracee, final, intermediate);
		if (status < 0)
			return status;				
	} else {
		/* If it is the last, delete the intermediate and final*/
		status = unlink(intermediate);
		if (status < 0)
			return status;
		status = unlink(final);
		if (status < 0)
			return status;
		if (strncmp(final, shadow_path, strlen(shadow_path)) == 0) {
			status = unlink_meta(tracee, final);
			if (status < 0)
				return status;
			strncpy(shadow, final, strlen(final) - 5);
			shadow[strlen(final) - 5] = '\0';
			status = unlink(shadow);
			if (status < 0)
				return status;
		}
	}

	return 0;
}

/******************************************************
 * Create File - shadow to noexec if in rootfs  
 ******************************************************/
static int handle_creat(Tracee *tracee, Reg path_sysarg, Reg mode_sysarg)
{
	int size;
	int status;
	char orig_path[PATH_MAX];
	char final_path[PATH_MAX];

	//get original path
	size = read_string(tracee, orig_path, peek_reg(tracee, CURRENT, path_sysarg), PATH_MAX);
	if (size < 0)
                return size;
        if (size >= PATH_MAX)
                return -ENAMETOOLONG;
	if (!belongs_to_guestfs(tracee, orig_path))
		return 0;

	status = link_shadow_path(tracee, final_path, orig_path, true);
	if (status < 0)
		return status;

	if (status == 0) {
		status = new_shadow_file_path(tracee, final_path);
		if (status < 0)
			return status;
		status = creat_meta(tracee, orig_path, final_path, mode_sysarg);
		if (status < 0)
			return status;
		status = my_symlink(tracee, orig_path, final_path);
		if (status < 0)
			return status;
	}
	
	//modify path sysarg to point at shadow location
	return set_sysarg_path(tracee, final_path, path_sysarg);
}

/******************************************************
 * Create special or ordinary file - shadow to noexec  
 * if in rootfs and a regular file
 ******************************************************/
static int handle_mknod(Tracee *tracee, Reg path_sysarg, Reg mode_sysarg)
{
	word_t mode;
	int size;
	int status;
	char orig_path[PATH_MAX];
	char final_path[PATH_MAX];

	//get mode
	mode = peek_reg(tracee, ORIGINAL, mode_sysarg);

	//don't mess with special (non-regular) files.  they need to go on internal storage
	if (!S_ISREG(mode))
		return 0;

	//get original path
	size = read_string(tracee, orig_path, peek_reg(tracee, CURRENT, path_sysarg), PATH_MAX);
	if (size < 0)
                return size;
        if (size >= PATH_MAX)
                return -ENAMETOOLONG;
	if (!belongs_to_guestfs(tracee, orig_path))
		return 0;

	status = link_shadow_path(tracee, final_path, orig_path, true);
	if (status < 0)
		return status;
	
	if (status == 0) {
		status = new_shadow_file_path(tracee, final_path);
		if (status < 0)
			return status;
		status = creat_meta(tracee, orig_path, final_path, mode_sysarg);
		if (status < 0)
			return status;
		status = my_symlink(tracee, orig_path, final_path);
		if (status < 0)
			return status;
	}
	
	//modify path sysarg to point at shadow location
	return set_sysarg_path(tracee, final_path, path_sysarg);
}

/******************************************************
 * Make a hard link.  Create a fake hardlink using 
 * symbolic links that point to the actual file.
 ******************************************************/
static int handle_link(Tracee *tracee, Reg path_sysarg)
{
	return move_and_symlink_path(tracee, path_sysarg);
}

/******************************************************
 * Remove a link - remove symbolic link if fake hard 
 * link.  Remove file in shadow and here if last link
 * or not a fake hard link and a regular file. 
 ******************************************************/
static int handle_unlink(Tracee *tracee, Reg path_sysarg)
{
	return decrement_link_count(tracee, path_sysarg);
}

/******************************************************
 * Move a file - If a file is being moved on top of 
 * and that file is a hard link, handle it like unlink.
 * Also shadow the move if it is a regular file.
 ******************************************************/
static int handle_rename(Tracee *tracee, Reg oldpath_sysarg, Reg newpath_sysarg)
{
	char oldpath[PATH_MAX];
	char newpath[PATH_MAX];
	int size;

	/* Note: this path was already canonicalized.  */
	size = read_string(tracee, oldpath, peek_reg(tracee, CURRENT, oldpath_sysarg), PATH_MAX);
	if (size < 0)
		return size;
	if (size >= PATH_MAX)
		return -ENAMETOOLONG;

	/* Note: this path was already canonicalized.  */
	size = read_string(tracee, newpath, peek_reg(tracee, CURRENT, newpath_sysarg), PATH_MAX);
	if (size < 0)
		return size;
	if (size >= PATH_MAX)
		return -ENAMETOOLONG;

	//do nothing if the old and new file are the same
	if (strcmp(oldpath,newpath) == 0)
		return 0;

	return decrement_link_count(tracee, newpath_sysarg);
}

/******************************************************
 * If creating a file - shadow to noexec
 * If openning a file:
 *	If openning for read and elf or script: copy 
 *	  from shadow to executable location and return
 *	  that file's handle.
 *	If regular file: open shadow version instead
 *	  by modifying path.
 *	If fake hard link: open file that fake hardlink
 *	  points at.
 *	If symbolic link or special file: don't
 *	  modify.
 ******************************************************/
static int handle_open(Tracee *tracee, Reg path_sysarg, Reg flags_sysarg, Reg mode_sysarg)
{
	word_t flags;
	int size;
	int status;
	char orig_path[PATH_MAX];
	char final_path[PATH_MAX];

	//get original path
	size = read_string(tracee, orig_path, peek_reg(tracee, CURRENT, path_sysarg), PATH_MAX);
	if (size < 0)
                return size;
        if (size >= PATH_MAX)
                return -ENAMETOOLONG;
	if (!belongs_to_guestfs(tracee, orig_path))
		return 0;

	//get flags
	flags = peek_reg(tracee, ORIGINAL, flags_sysarg);

	//get path to real file
	status = link_shadow_path(tracee, final_path, orig_path, !(flags & O_NOFOLLOW));
	if (status < 0)
                return status;

	if ((status == 0) && ((flags & O_CREAT) == 0))
		return 0;

	if ((status == 0) && (flags & O_CREAT)) {
		status = new_shadow_file_path(tracee, final_path);
		if (status < 0)
			return status;
		status = creat_meta(tracee, orig_path, final_path, mode_sysarg);
		if (status < 0)
			return status;
		status = my_symlink(tracee, final_path, orig_path);
		if (status < 0)
			return status;
	}

	//modify path sysarg to point at shadow location
	return set_sysarg_path(tracee, final_path, path_sysarg);
}

/******************************************************
 * Modify the link count to match the fake hard link
 * count
 ******************************************************/
static int handle_any_stat(Tracee *tracee, char path[PATH_MAX], Reg stat_struct_sysarg, struct stat statl) 
{
	word_t result;
	int status;
	char shadow_path[PATH_MAX];
	char * name;
	char * period;
	char meta_path[PATH_MAX];
	struct stat meta_statl;

	printf("handle_and_stat path: %s\n", path);

	/* Override only if it succeed.  */
	result = peek_reg(tracee, CURRENT, SYSARG_RESULT);
	if (result != 0)
		return 0;

	name = strrchr(path, '/');
	if (name == NULL)
		name = path;
	else
		name++;

	status = translate_path_and_notify(tracee, shadow_path, AT_FDCWD, SHADOW_PATH, false, false); 
	if (status < 0)
		return status;

	//name does have the LINK_PREFIX or the path does not start with the SHADOW_PATH translated
	//get out of here
	if ((strncmp(name, LINK_PREFIX, strlen(LINK_PREFIX)) != 0) && (strncmp(path, shadow_path, strlen(shadow_path)) != 0))
		return 0;

	//if it is a link get out of here
	if (S_ISLNK(statl.st_mode))
		return 0;

	//if it is a shadowed file, get most of its meta data from the meta file
	//TODO, right now only handling mtime as a test of whether it fixes apt-get issues
	if (strncmp(path, shadow_path, strlen(shadow_path)) == 0) {
		status = get_meta_path(tracee, meta_path, path); 
		if (status < 0)
			return status;
		status = lstat(meta_path, &meta_statl);
		//TODO, if it was deleted, we need to still get the meta data
		if (status == 0)
			statl.st_mtime = meta_statl.st_mtime;
	}

	period = strchr(name, '.');

	if (period != NULL)
		statl.st_nlink = atoi(path + strlen(path) - 4);

	status = write_data(tracee, peek_reg(tracee, ORIGINAL,  stat_struct_sysarg), &statl, sizeof(statl));
	if (status < 0)
		return status;

	return 0;
}

/******************************************************
 * Pull out the path from the file descriptor
 * and then call common function that peices together
 * stat struct
 ******************************************************/
static int handle_fstat(Tracee *tracee, Reg fd_sysarg, Reg stat_struct_sysarg)
{
	int status;
	char original[PATH_MAX];
	struct stat statl;

	status = readlink_proc_pid_fd(tracee->pid, peek_reg(tracee, MODIFIED, fd_sysarg), original);
	if (status < 0)
		return status;
	printf("handle_fstat original: %s\n", original);
	if (strcmp(original + strlen(original) - strlen(DELETED_SUFFIX), DELETED_SUFFIX) == 0)
		original[strlen(original) - strlen(DELETED_SUFFIX)] = '\0'; 

	// Get stat structure
	status = read_data(tracee, &statl, peek_reg(tracee, MODIFIED, stat_struct_sysarg), sizeof(statl));
	if (status < 0) {
		printf("getting oringal stat failed\n");
		return status;
	}

	return handle_any_stat(tracee, original, stat_struct_sysarg, statl);
}

/******************************************************
 * Pull out the path from the path_sysarg
 * and then call common function that peices together
 * stat struct
 ******************************************************/
static int handle_stat(Tracee *tracee, Reg path_sysarg, Reg stat_struct_sysarg)
{
	int size;
	int status;
	char original[PATH_MAX];
	char shadow[PATH_MAX];
	word_t sysnum;
	struct stat statl;

	size = read_string(tracee, original, peek_reg(tracee, MODIFIED, path_sysarg), PATH_MAX);
	if (size < 0)
		return size;
	if (size >= PATH_MAX)
		return -ENAMETOOLONG;

        sysnum = get_sysnum(tracee, ORIGINAL);

	status = link_shadow_path(tracee, shadow, original, (sysnum != PR_lstat) && (sysnum != PR_lstat64) && (sysnum != PR_oldlstat));
	if (status <= 0)
		return status;

	printf("handle_stat shadow: %s\n", shadow);
	status = lstat(shadow, &statl);
	if (status < 0)
		return status;

	return handle_any_stat(tracee, shadow, stat_struct_sysarg, statl);
}

static int handle_exec_path(Tracee *tracee, char exec_path[PATH_MAX])
{
	int status;
	char shadow_path[PATH_MAX];

	printf("handle_exec_path exec_path: %s\n", exec_path);

	//if (!belongs_to_guestfs(tracee, exec_path))
	//	return 0;

	status = link_shadow_path(tracee, shadow_path, exec_path, true);
	if (status <= 0)
		return status;

	status = copy_executable(tracee, shadow_path, exec_path);
	if (status <= 0)
		return status;

	return 0;
}

static int handle_mmap(Tracee *tracee, ExtensionEvent event)
{

	int status;
	word_t flags;
	char path[PATH_MAX];
	char final_path[PATH_MAX];

	switch (event) {

	case SYSCALL_ENTER_START: {

		switch (get_sysnum(tracee, ORIGINAL)) {

		case PR_mmap:
		case PR_mmap2:

			flags = peek_reg(tracee, ORIGINAL, SYSARG_4);

			if ((flags & MAP_ANONYMOUS) != 0)
				break;

			status = readlink_proc_pid_fd(tracee->pid, peek_reg(tracee, ORIGINAL, SYSARG_5), path);
			if (status < 0)
				return status;
			if (strcmp(path + strlen(path) - strlen(DELETED_SUFFIX), DELETED_SUFFIX) == 0)
				path[strlen(path) - strlen(DELETED_SUFFIX)] = '\0'; 

			status = copy_executable(tracee, path, final_path);
			if (status <= 0)
				return status;

			/* Replace mmap(2) with open(2).  */
			set_sysnum(tracee, PR_open);
			set_sysarg_path(tracee, final_path, SYSARG_1);
			poke_reg(tracee, SYSARG_2, O_RDWR);
			poke_reg(tracee, SYSARG_3, 0);

			/* Chain this substituted syscall with mmap(2).  Use -1 for fd
			 * since its value is not known as of now (this will be the
			 * result of the preceding open(2).  */
			register_chained_syscall(tracee, PR_mmap2, peek_reg(tracee, ORIGINAL, SYSARG_1), peek_reg(tracee, ORIGINAL, SYSARG_2), peek_reg(tracee, ORIGINAL, SYSARG_3), peek_reg(tracee, ORIGINAL, SYSARG_4), -1, peek_reg(tracee, ORIGINAL, SYSARG_6));

			/* Don't leak the temporary file descriptor (same remark about
			 * fd == -1).  */
			register_chained_syscall(tracee, PR_close, -1, 0, 0, 0, 0, 0);
	
			break;

		default:
			break;

		}
		return 0;
	}

	case SYSCALL_CHAINED_ENTER: {

		switch (get_sysnum(tracee, CURRENT)) {

		case PR_mmap2:
			/* Replace the fd placeholder with the result of the preceding
			 * open(2).  */
			poke_reg(tracee, SYSARG_5, temporary_fd);
			break;

		case PR_close:
			/* Replace the fd placeholder with the result of the preceding
			 * open(2).  */
			poke_reg(tracee, SYSARG_1, temporary_fd);
			break;

		default:
			break;

		}
		return 0;
	}

	case SYSCALL_CHAINED_EXIT: {

		switch (get_sysnum(tracee, CURRENT)) {

		case PR_open:
			//save off result of open
			temporary_fd = peek_reg(tracee, CURRENT, SYSARG_RESULT);
			break;

		case PR_mmap2:
			/* The return value of this chain of syscall is now known.  */
			force_chain_final_result(tracee, peek_reg(tracee, CURRENT, SYSARG_RESULT));
			break;

		default:
			break;

		}
		return 0;
	}

	default:
		return 0;
	}
}

static int handle_sysexit_end(Tracee *tracee)
{
	word_t sysnum;
	Reg sysarg = SYSARG_NUM;
	Reg sysarg2 = SYSARG_NUM;
	int status;

        sysnum = get_sysnum(tracee, ORIGINAL);

        switch (sysnum) {
	/*for all the fstat functions we need to piece back together the status struc
	 * from the shadow and the non-shadow info
	 */
        case PR_fstat:                     //int fstat(int fd, struct stat *buf); 
        case PR_fstat64:                   //int fstat(int fd, struct stat *buf);
        case PR_oldfstat:                  //int fstat(int fd, struct stat *buf);
		sysarg = SYSARG_1;
		sysarg2 = SYSARG_2;
		status = handle_fstat(tracee, sysarg, sysarg2);
		if (status < 0)
			return status;
		break;
        case PR_fstatat64:                 //int fstatat(int dirfd, const char *pathname, struct stat *buf, int flags);
		sysarg++;
        case PR_newfstatat:                //int fstatat(int dirfd, const char *pathname, struct stat *buf, int flags);
        case PR_stat:                      //int stat(const char *path, struct stat *buf);
        case PR_stat64:                    //int stat(const char *path, struct stat *buf);
        case PR_oldstat:                   //int stat(const char *path, struct stat *buf); 
        case PR_lstat:                     //int lstat(const char *path, struct stat *buf);
        case PR_lstat64:                   //int lstat(const char *path, struct stat *buf);
        case PR_oldlstat:                  //int lstat(const char *path, struct stat *buf); 
		sysarg++;
		sysarg2 = sysarg + 1;
		status = handle_stat(tracee, sysarg, sysarg2);
		if (status < 0)
			return status;
		break;
	default:
		return 0;
	}
	return 0;
}

/**
 * Handler for this @extension.  It is triggered each time an @event
 * occurred.  See ExtensionEvent for the meaning of @data1 and @data2.
 */
int droid_root_callback(Extension *extension, ExtensionEvent event,
			intptr_t data1, intptr_t data2 UNUSED)
{
	int status;
	Tracee *tracee;
	Reg sysarg = SYSARG_NUM;
	Reg sysarg2 = SYSARG_NUM;
	Reg sysarg3 = SYSARG_NUM;

	switch (event) {
	case INITIALIZATION: {
		/* List of syscalls handled by this extensions.  */
		static FilteredSysnum filtered_sysnums[] = {
			/***************************************
			 *Create
			 ***************************************/
			{ PR_creat,		FILTER_SYSEXIT },
			{ PR_mknod,		FILTER_SYSEXIT },
			{ PR_mknodat,		FILTER_SYSEXIT },
                        { PR_link,              FILTER_SYSEXIT },
                        { PR_linkat,            FILTER_SYSEXIT },
			/***************************************
			 *Delete
			 ***************************************/
                        { PR_unlink,            FILTER_SYSEXIT },
                        { PR_unlinkat,          FILTER_SYSEXIT },
			/***************************************
			 *Move
			 ***************************************/
                        { PR_rename,            FILTER_SYSEXIT },
                        { PR_renameat,          FILTER_SYSEXIT },
			/***************************************
			 *Get metadata
			 ***************************************/
                        { PR_fstat,             FILTER_SYSEXIT },
                        { PR_fstat64,           FILTER_SYSEXIT },
                        { PR_fstatat64,         FILTER_SYSEXIT },
                        { PR_newfstatat,        FILTER_SYSEXIT },
			{ PR_oldfstat,		FILTER_SYSEXIT },
                        { PR_lstat,             FILTER_SYSEXIT },
                        { PR_lstat64,		FILTER_SYSEXIT },
			{ PR_oldlstat,		FILTER_SYSEXIT },
                        { PR_stat,		FILTER_SYSEXIT },
                        { PR_stat64,		FILTER_SYSEXIT },
			{ PR_oldstat,		FILTER_SYSEXIT },
			/***************************************
			 *Set metadata
			 ***************************************/
			{ PR_fchmodat,		FILTER_SYSEXIT },
			{ PR_fchownat,		FILTER_SYSEXIT },
			{ PR_futimesat,		FILTER_SYSEXIT },
			{ PR_utimensat,		FILTER_SYSEXIT },
			{ PR_chmod,		FILTER_SYSEXIT },
			{ PR_chown,		FILTER_SYSEXIT },
			{ PR_lchown,		FILTER_SYSEXIT },
			{ PR_chown32,		FILTER_SYSEXIT },
			{ PR_lchown32,		FILTER_SYSEXIT },
			{ PR_utime,		FILTER_SYSEXIT },
			{ PR_utimes,		FILTER_SYSEXIT },
			//TODO, these ones require a file descriptor and not a path
			//{ PR_fchown,		FILTER_SYSEXIT },
			//{ PR_fchown32,		FILTER_SYSEXIT },
			//{ PR_fchmod,		FILTER_SYSEXIT },
			/***************************************
			 * Get content
			 ***************************************/
			//{ PR_getdents,	FILTER_SYSEXIT },
			//{ PR_getdents64,	FILTER_SYSEXIT },
			/***************************************
			 * Set content
			 ***************************************/
			{ PR_truncate,		FILTER_SYSEXIT },
			{ PR_truncate64,	FILTER_SYSEXIT },
			/***************************************
			 * Misc.
			 ***************************************/
			{ PR_openat,		FILTER_SYSEXIT },
			{ PR_open,		FILTER_SYSEXIT },
			{ PR_mmap,		FILTER_SYSEXIT },
			{ PR_mmap2,		FILTER_SYSEXIT },
			FILTERED_SYSNUM_END,
		};
		extension->filtered_sysnums = filtered_sysnums;
		return 0;
	}

	case SYSCALL_ENTER_START: 
	case SYSCALL_CHAINED_ENTER: 
	case SYSCALL_CHAINED_EXIT: 
		return handle_mmap(TRACEE(extension), event);


	case SYSCALL_ENTER_END: {
		tracee = TRACEE(extension);

		switch (get_sysnum(tracee, ORIGINAL)) {

		/******************************************************
		 * Create File - shadow to noexec if in rootfs  
		 ******************************************************/
		case PR_creat:
			/*int creat(const char *pathname, mode_t mode);*/
			sysarg++;
			sysarg2 = sysarg + 1;
			status = handle_creat(tracee, sysarg, sysarg2);
			if (status < 0)
				return status;
			break;

		/******************************************************
		 * Create special or ordinary file - shadow to noexec 
                 * if in rootfs and a regular file
		 ******************************************************/
		case PR_mknodat:
			/*int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev);*/
			sysarg++;

		case PR_mknod:
			/*int mknod(const char *pathname, mode_t mode, dev_t dev);*/
			sysarg++;
			sysarg2 = sysarg + 1;
			status = handle_mknod(tracee, sysarg, sysarg2);
			if (status < 0)
				return status;
			break;

		/******************************************************
		 * Make a hard link.  Create a fake hardlink using 
		 * symbolic links that point to the actual file.
		 ******************************************************/
		case PR_linkat:
			/*int linkat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags);*/
			sysarg++;

		case PR_link:
			/*int link(const char *oldpath, const char *newpath); */
			sysarg++;
			status = handle_link(tracee, sysarg);
			if (status < 0)
				return status;
			break;

		/******************************************************
		 * Remove a link - remove symbolic link if fake hard 
		 * link.  Remove file in shadow and here if last link
		 * or not a fake hard link and a regular file. 
		 ******************************************************/
		case PR_unlinkat:
			/*int unlinkat(int dirfd, const char *pathname, int flags);*/
			sysarg++;

		case PR_unlink:
			/*int unlink(const char *pathname);*/
			sysarg++;
			status = handle_unlink(tracee, sysarg);
			if (status < 0)
				return status;
			break;

		/******************************************************
		 * Move a file - If a file is being moved on top of 
		 * and that file is a hard link, handle it like unlink.
		 * Also shadow the move if it is a regular file.
		 ******************************************************/
		case PR_renameat:
			/*int renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath);*/
			sysarg = SYSARG_2;
			sysarg2 = SYSARG_4;
			status = handle_rename(tracee, sysarg, sysarg2);
			if (status < 0)
				return status;
			break;

		case PR_rename:
			/*int rename(const char *oldpath, const char *newpath);*/
			sysarg = SYSARG_1;
			sysarg2 = SYSARG_2;
			status = handle_rename(tracee, sysarg, sysarg2);
			if (status < 0)
				return status;
			break;

		/******************************************************
		 * Set metadata - if it is a shadow file, point it
		 * at the meta file instead
		 ******************************************************/
		case PR_fchmodat:
		case PR_fchownat:
		case PR_futimesat:
		case PR_utimensat:
			sysarg++;
		case PR_chmod:	
		case PR_chown:	
		case PR_lchown:
		case PR_chown32:
		case PR_lchown32:
		case PR_utime:	
		case PR_utimes:
			sysarg++;
			status = set_meta_path(tracee, sysarg);
			if (status < 0)
				return status;
			break;
		case PR_fchown:
		case PR_fchown32:
		case PR_fchmod:	
			//TODO: will need to handle these and other things that can effect meta data
			//like opening, reading or writing a file
			sysarg++;
			break;

		/******************************************************
		 * If creating a file - shadow to noexec
		 * If openning a file:
		 *	If openning for read and elf or script: copy 
		 *	  from shadow to executable location and return
		 *	  that file's handle.
		 *	If regular file: open shadow version instead
		 *	  by modifying path.
		 *	If fake hard link: open file that fake hardlink
		 *	  points at.
		 *	If symbolic link or special file: don't
		 *	  modify.
		 ******************************************************/
		case PR_openat:
			/*int openat(int dirfd, const char *pathname, int flags, mode_t mode);*/
			sysarg++;

		case PR_open:
			/*int open(const char *pathname, int flags, mode_t mode);*/
			sysarg++;
			sysarg2 = sysarg + 1;
			sysarg3 = sysarg + 2;
			status = handle_open(tracee, sysarg, sysarg2, sysarg3);
			if (status < 0)
				return status;
			break;

		default:
			break;

		}
		return 0;
	}

	case SYSCALL_EXIT_END: {
		return handle_sysexit_end(TRACEE(extension));
	}

	case EXEC_PATH: {
		return handle_exec_path(TRACEE(extension), (char *) data1);
	}

	default:
		return 0;
	}
}
